AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Jenkins application infrastructure'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - production
    Description: Environment name for resource naming

  DefaultModel:
    Type: String
    Default: us.meta.llama3-3-70b-instruct-v1:0
    Description: Default model to use for note generation and labeling
    AllowedValues:
      - us.meta.llama3-3-70b-instruct-v1:0
      - meta.llama3-1-405b-instruct-v1:0
      - meta.llama3-1-70b-instruct-v1:0
      - anthropic.claude-3-7-sonnet-20250219-v1:0

  HostedZoneId:
    Type: AWS::Route53::HostedZone::Id
    Description: The Route53 Hosted Zone ID of the domain

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC where the resources will be deployed

  PublicSubnets:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Public subnets for ALB

  PrivateSubnets:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnets for Fargate tasks

  DomainName:
    Type: String
    Description: Domain name for the application

  AuthDomainPrefix:
    Type: String
    Description: Prefix for Cognito auth domain

  AccessTokenSecret:
    Type: String
    NoEcho: true
    Description: Secret for signing JWT tokens

  DBName:
    Type: String
    Description: Aurora database name

  DBUser:
    Type: String
    Description: Aurora master username

  DBPassword:
    Type: String
    NoEcho: true
    Description: Aurora master password

Resources:
  JenkinsS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub jenkins-os-${AWS::AccountId}
      VersioningConfiguration:
        Status: Enabled
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, PUT, POST, DELETE]
            AllowedOrigins: ['*']
            MaxAge: 3000

  # IAM Role for the Lambda function
  UploadFilesLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:ListBucket
                  - s3:GetObject
                Resource:
                  - !Sub arn:aws:s3:::${JenkinsS3Bucket}
                  - !Sub arn:aws:s3:::${JenkinsS3Bucket}/*
                  - arn:aws:s3:::os-jenkins-copy
                  - arn:aws:s3:::os-jenkins-copy/*

  # Lambda function for file uploads - CORRECTED VERSION
  UploadFilesLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-UploadFiles-${Environment}"
      Description: "Copies prompts and sample-recordings folders from public S3 bucket to Jenkins S3 bucket"
      Handler: index.handler
      Role: !GetAtt UploadFilesLambdaRole.Arn
      Runtime: python3.9
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          BUCKET_NAME: !Ref JenkinsS3Bucket
          SOURCE_BUCKET: "os-jenkins-copy"
      Code:
        ZipFile: |
          import os
          import json
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          s3 = boto3.client('s3')
          
          def handler(event, context):
              logger.info('Received event: %s', json.dumps(event))
              
              target_bucket = os.environ['BUCKET_NAME']
              source_bucket = os.environ['SOURCE_BUCKET']
              response_data = {}
              
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      logger.info(f'Copying specific folders from {source_bucket} to {target_bucket}')
                      
                      # Only copy these specific folders
                      folders_to_copy = [
                          'prompts/',
                          'sample-recordings/'
                      ]
                      
                      total_files = 0
                      
                      for folder in folders_to_copy:
                          logger.info(f'Copying folder: {folder}')
                          folder_files = 0
                          
                          try:
                              # List all objects in this specific folder
                              paginator = s3.get_paginator('list_objects_v2')
                              for page in paginator.paginate(Bucket=source_bucket, Prefix=folder):
                                  if 'Contents' in page:
                                      for obj in page['Contents']:
                                          source_key = obj['Key']
                                          
                                          # Skip if it's just the folder itself (ends with /)
                                          if source_key.endswith('/'):
                                              continue
                                          
                                          # Copy the file
                                          copy_source = {
                                              'Bucket': source_bucket,
                                              'Key': source_key
                                          }
                                          
                                          logger.info(f'Copying: {source_key}')
                                          s3.copy_object(
                                              CopySource=copy_source,
                                              Bucket=target_bucket,
                                              Key=source_key  # Keep same path structure
                                          )
                                          folder_files += 1
                                          total_files += 1
                              
                              logger.info(f'Copied {folder_files} files from {folder}')
                              
                          except Exception as folder_error:
                              logger.error(f'Error copying folder {folder}: {folder_error}')
                              # Continue with next folder instead of failing completely
                      
                      response_data['Status'] = 'SUCCESS'
                      response_data['FileCount'] = total_files
                      response_data['FoldersCopied'] = folders_to_copy
                      logger.info(f'Successfully copied {total_files} files from {len(folders_to_copy)} folders')
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                      
                  else:
                      # Delete event - no action needed
                      logger.info('Delete event, no action needed')
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                      
              except Exception as e:
                  logger.error('Error: %s', str(e), exc_info=True)
                  response_data['Status'] = 'FAILED'
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

  # Custom resource to trigger the Lambda function
  UploadFilesCustomResource:
    Type: Custom::UploadFiles
    DependsOn: JenkinsS3Bucket
    Properties:
      ServiceToken: !GetAtt UploadFilesLambda.Arn
      # Include a version parameter to force updates when redeployed
      Version: "1.0"

  # Update S3 bucket policy to allow access
  JenkinsS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref JenkinsS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowECSTaskAccess
            Effect: Allow
            Principal:
              AWS: !GetAtt ECSTaskRole.Arn
            Action:
              - s3:GetObject
              - s3:PutObject
              - s3:DeleteObject
              - s3:ListBucket
            Resource:
              - !Sub arn:aws:s3:::${JenkinsS3Bucket}
              - !Sub arn:aws:s3:::${JenkinsS3Bucket}/*
          - Sid: AllowLambdaAccess
            Effect: Allow
            Principal:
              AWS: !GetAtt UploadFilesLambdaRole.Arn
            Action:
              - s3:PutObject
              - s3:ListBucket
              - s3:GetObject
            Resource:
              - !Sub arn:aws:s3:::${JenkinsS3Bucket}
              - !Sub arn:aws:s3:::${JenkinsS3Bucket}/*

  # Aurora RDS Cluster - Updated for Serverless v2
  AuroraDBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for Aurora cluster
      SubnetIds: !Ref PrivateSubnets

  AuroraSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Aurora cluster
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref JenkinsSecurityGroup
      SecurityGroupEgress:
        - IpProtocol: '-1'
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  AuroraCluster:
    Type: AWS::RDS::DBCluster
    Properties:
      Engine: aurora-postgresql
      EngineVersion: '16.6'
      EngineMode: provisioned
      MasterUsername: !Ref DBUser
      MasterUserPassword: !Ref DBPassword
      DatabaseName: !Ref DBName
      DBSubnetGroupName: !Ref AuroraDBSubnetGroup
      VpcSecurityGroupIds:
        - !Ref AuroraSecurityGroup
      BackupRetentionPeriod: 7
      PreferredBackupWindow: '06:34-07:04'
      PreferredMaintenanceWindow: 'sun:12:14-sun:12:44'
      StorageEncrypted: true
      DeletionProtection: true
      EnableHttpEndpoint: false
      EnableIAMDatabaseAuthentication: false
      Port: 5432
      EnableCloudwatchLogsExports:
        - postgresql
      # Serverless v2 scaling configuration
      ServerlessV2ScalingConfiguration:
        MinCapacity: 0.5
        MaxCapacity: 2
      Tags:
        - Key: Environment
          Value: !Ref Environment

  AuroraInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      Engine: aurora-postgresql
      DBClusterIdentifier: !Ref AuroraCluster
      DBInstanceClass: db.serverless
      PubliclyAccessible: false
      EnablePerformanceInsights: true
      PerformanceInsightsRetentionPeriod: 731  # Maximum allowed retention period (731 days)
      MonitoringInterval: 60
      MonitoringRoleArn: !GetAtt EnhancedMonitoringRole.Arn
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # IAM Role for Enhanced Monitoring
  EnhancedMonitoringRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: monitoring.rds.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole

  # ECR Repositories
  FrontendECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Join ['-', ['jenkins-os-frontend', !Ref Environment]]
      ImageTagMutability: MUTABLE

  BackendECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Join ['-', ['jenkins-os-backend', !Ref Environment]]
      ImageTagMutability: MUTABLE

  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Join ['-', ['JenkinsOS', !Ref Environment]]
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: false
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email
      MfaConfiguration: "OFF"
      # Enable standard attributes for OpenID Connect scopes
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: given_name
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: family_name
          AttributeDataType: String
          Required: false
          Mutable: true

  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref CognitoUserPool
      ClientName: !Join ['-', ['jenkins-os-client', !Ref Environment]]
      GenerateSecret: false
      # Auth flows for user authentication
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      # OAuth 2.0 settings
      CallbackURLs:
        - !Sub https://${DomainName}/login
      LogoutURLs:
        - !Sub https://${DomainName}
      # OAuth grant types - Authorization code grant
      AllowedOAuthFlows:
        - code
      # OpenID Connect scopes - email, openid, profile
      AllowedOAuthScopes:
        - email
        - openid
        - profile
      AllowedOAuthFlowsUserPoolClient: true
      # Additional security settings
      PreventUserExistenceErrors: ENABLED
      SupportedIdentityProviders:
        - COGNITO  # Cognito user pool directory as identity provider
      # Token validity settings
      AccessTokenValidity: 60  # 1 hour
      IdTokenValidity: 60      # 1 hour
      RefreshTokenValidity: 30 # 30 days
      TokenValidityUnits:
        AccessToken: minutes
        IdToken: minutes
        RefreshToken: days
      
  CognitoUserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Ref AuthDomainPrefix
      UserPoolId: !Ref CognitoUserPool

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ['-', ['jenkins-os-cluster', !Ref Environment]]
      CapacityProviders:
        - FARGATE

  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AmazonTranscribeFullAccess
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: "*"

  ECSExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess

  FrontendTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join ['-', ['jenkins-os-frontend', !Ref Environment]]
      Cpu: '512'
      Memory: '1024'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref ECSExecutionRole
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: jenkins-os-frontend
          Image: public.ecr.aws/s9f8j1d3/jenkins-os-frontend:latest
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: /ecs/jenkins-os-frontend
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
              awslogs-create-group: 'true'
          PortMappings:
            - ContainerPort: 4000
              Protocol: tcp
          Environment:
            - Name: NEXT_PUBLIC_BACKEND_URL
              Value: !Sub https://api.${DomainName}
            - Name: NEXT_PUBLIC_AWS_REGION
              Value: !Ref AWS::Region
            - Name: NEXT_PUBLIC_COGNITO_DOMAIN
              Value: !Sub https://${AuthDomainPrefix}.auth.${AWS::Region}.amazoncognito.com
            - Name: NEXT_PUBLIC_COGNITO_CLIENT_ID
              Value: !Ref CognitoUserPoolClient
            - Name: NEXT_PUBLIC_COGNITO_REDIRECT_URI
              Value: !Sub https://${DomainName}/login
            - Name: NEXT_PUBLIC_COGNITO_LOGOUT_URI
              Value: !Sub https://${DomainName}
            - Name: NEXT_PUBLIC_USE_COGNITO
              Value: 'true'
            - Name: NEXT_PUBLIC_USE_GOOGLE_AUTH
              Value: 'false'

  BackendTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join ['-', ['jenkins-os-backend', !Ref Environment]]
      Cpu: '1024'
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref ECSExecutionRole
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name: jenkins-os-backend
          Image: public.ecr.aws/s9f8j1d3/jenkins-os-backend:latest
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: /ecs/jenkins-os-backend
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
              awslogs-create-group: 'true'
          PortMappings:
            - ContainerPort: 8000
              Protocol: tcp
          Environment:
            - Name: FRONTEND_URL
              Value: !Sub https://${DomainName}
            - Name: ALLOWED_ORIGINS
              Value: !Sub https://${DomainName}
            - Name: GENERATIVE_AI_SERVICE
              Value: "AWS Bedrock"
            - Name: AWS_REGION
              Value: !Ref AWS::Region
            - Name: AWS_BUCKET_NAME
              Value: !Ref JenkinsS3Bucket
            - Name: COGNITO_USER_POOL_ID
              Value: !Ref CognitoUserPool
            - Name: COGNITO_APP_CLIENT_ID
              Value: !Ref CognitoUserPoolClient
            - Name: USE_COGNITO
              Value: 'true'
            - Name: ENVIRONMENT
              Value: !Ref Environment
            - Name: ACCESS_TOKEN_SECRET
              Value: !Ref AccessTokenSecret
            - Name: ACCESS_TOKEN_EXPIRE_MINUTES
              Value: "1440"
            - Name: USE_AURORA
              Value: "true"
            - Name: COOKIE_SECURE
              Value: "true"
            - Name: LOGGING_LEVEL
              Value: DEBUG
            - Name: DEFAULT_NOTE_GENERATION_MODEL
              Value: !Ref DefaultModel
            - Name: LABEL_MODEL
              Value: !Ref DefaultModel
            - Name: S3_BUCKET_NAME
              Value: !Ref JenkinsS3Bucket
            - Name: AURORA_WRITER_ENDPOINT
              Value: !GetAtt AuroraCluster.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DBName
            - Name: DB_USER
              Value: !Ref DBUser
            - Name: DB_PASSWORD
              Value: !Ref DBPassword
            - Name: DB_PORT
              Value: "5432"
            - Name: COGNITO_CLIENT_ID
              Value: !Ref CognitoUserPoolClient
            - Name: COGNITO_DOMAIN
              Value: !Sub https://${AuthDomainPrefix}.auth.${AWS::Region}.amazoncognito.com
            - Name: COGNITO_REDIRECT_URI
              Value: !Sub https://${DomainName}/login
            - Name: TRANSCRIPTION_SERVICE
              Value: "AWS Transcribe"
            - Name: COOKIE_DOMAIN
              Value: !Sub ".${DomainName}"  # Used for backend cookie domain configuration

  FrontendService:
    Type: AWS::ECS::Service
    DependsOn:
      - FrontendHTTPSListener
      - UploadFilesCustomResource
    Properties:
      ServiceName: !Join ['-', ['jenkins-os-frontend', !Ref Environment]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref FrontendTaskDefinition
      DesiredCount: 1
      EnableExecuteCommand: true
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref JenkinsSecurityGroup
          Subnets: !Ref PrivateSubnets
      LoadBalancers:
        - ContainerName: jenkins-os-frontend
          ContainerPort: 4000
          TargetGroupArn: !Ref FrontendTargetGroup

  BackendService:
    Type: AWS::ECS::Service
    DependsOn:
      - BackendHTTPSListener
      - UploadFilesCustomResource
      - AuroraInstance
    Properties:
      ServiceName: !Join ['-', ['jenkins-os-backend', !Ref Environment]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref BackendTaskDefinition
      DesiredCount: 1
      EnableExecuteCommand: true
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref JenkinsSecurityGroup
          Subnets: !Ref PrivateSubnets
      LoadBalancers:
        - ContainerName: jenkins-os-backend
          ContainerPort: 8000
          TargetGroupArn: !Ref BackendTargetGroup

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ALB
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  JenkinsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Jenkins application
      GroupName: !Sub jenkins-sg-${Environment}-${AWS::StackName}
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref ALBSecurityGroup
        - IpProtocol: tcp
          FromPort: 4000
          ToPort: 4000
          SourceSecurityGroupId: !Ref ALBSecurityGroup
        - IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          SourceSecurityGroupId: !Ref ALBSecurityGroup
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: '-1'
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  FrontendTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckEnabled: true
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 5
      Port: 4000
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: '60'
        - Key: slow_start.duration_seconds
          Value: '60'

  BackendTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckEnabled: true
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /healthcheck
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 5
      Port: 8000
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref VpcId

  ACMCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub ${DomainName}
      SubjectAlternativeNames:
        - !Sub api.${DomainName}
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Sub ${DomainName}
          HostedZoneId: !Ref HostedZoneId
        - DomainName: !Sub api.${DomainName}
          HostedZoneId: !Ref HostedZoneId

  DNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub ${DomainName}
      Type: A
      AliasTarget:
        DNSName: !GetAtt FrontendALB.DNSName
        HostedZoneId: !GetAtt FrontendALB.CanonicalHostedZoneID

  APIRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub api.${DomainName}
      Type: A
      AliasTarget:
        DNSName: !GetAtt BackendALB.DNSName
        HostedZoneId: !GetAtt BackendALB.CanonicalHostedZoneID

  FrontendALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Join ['-', ['jenkins-os-frontend', !Ref Environment]]
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
      Subnets: !Ref PublicSubnets
      SecurityGroups:
        - !Ref ALBSecurityGroup

  BackendALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Join ['-', ['jenkins-os-backend', !Ref Environment]]
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
      Subnets: !Ref PublicSubnets
      SecurityGroups:
        - !Ref ALBSecurityGroup

  FrontendHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref FrontendTargetGroup
      LoadBalancerArn: !Ref FrontendALB
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ACMCertificate

  BackendHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref BackendTargetGroup
      LoadBalancerArn: !Ref BackendALB
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ACMCertificate

  FrontendHTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: '443'
            StatusCode: HTTP_301
      LoadBalancerArn: !Ref FrontendALB
      Port: 80
      Protocol: HTTP

  BackendHTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: '443'
            StatusCode: HTTP_301
      LoadBalancerArn: !Ref BackendALB
      Port: 80
      Protocol: HTTP

Outputs:
  S3BucketName:
    Description: Name of the S3 bucket for application files
    Value: !Ref JenkinsS3Bucket
    Export:
      Name: !Sub "${AWS::StackName}-S3BucketName"
      
  CognitoUserPoolId:
    Description: ID of the Cognito User Pool
    Value: !Ref CognitoUserPool
    Export:
      Name: !Sub "${AWS::StackName}-UserPoolId"
      
  CognitoAppClientId:
    Description: ID of the Cognito App Client
    Value: !Ref CognitoUserPoolClient
    Export:
      Name: !Sub "${AWS::StackName}-AppClientId"
      
  FrontendURL:
    Description: URL of the frontend application
    Value: !Sub "https://${DomainName}"
    Export:
      Name: !Sub "${AWS::StackName}-FrontendURL"
      
  BackendURL:
    Description: URL of the backend API
    Value: !Sub "https://api.${DomainName}"
    Export:
      Name: !Sub "${AWS::StackName}-BackendURL"
      
  DatabaseEndpoint:
    Description: Aurora cluster endpoint
    Value: !GetAtt AuroraCluster.Endpoint.Address
    Export:
      Name: !Sub "${AWS::StackName}-DatabaseEndpoint"